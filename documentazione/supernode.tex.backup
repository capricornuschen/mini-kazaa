\chapter{Super Node}
Il package \verb|lpr.minikazaa.supernode| non contiene un gran numero di classi peculiari, ma attinge molto dal package per gli Ordinary Node.
Fornisce però l'interfaccia per le \emph{callbacks} RMI che viene utilizzata da tutto il client.
Di seguito mostriamo le caratteristiche principali del package \verb|supernode|.
\section{L'interfaccia per le callback}
L'interfaccia per le callback fonisce due metodi semplici ma fondamentali.
\begin{lstlisting}
public void notifyMeAdd(NodeInfo new_node)
	throws RemoteException;

public void notifyMeRemove(NodeInfo new_node)
	throws RemoteException;
\end{lstlisting}
Questi due metodi servono al client per mantenersi aggiornato sui SN presenti nella rete.
L'implementazione di questi due metodi è molto semplice poichè opera solo delle \verb|add| o \verb|remove| alla struttura \emph{SupernodeList}.
Non è pertanto interessante mostrarne il codice.

\section{Indicizzamento dei file degli ON collegati}
Come abbiamo già detto, gli Ordinary Node condividono i propri file attraverso il Super Node che scelgono come ``amico''. Un Super Node quindi ha bisogno di uno strumento per indicizzare le informazioni sui file condivisi che gli arrivano dalla rete.

Per questo motivo è stata predisposta una classe il cui obiettivo è tenere in memoria tutti i file condivisi dagli Ordinary Node.
\verb|SupernodeOnFileList.java| svolge proprio questo compito.
\`{E} composta da un unico attributo che viene inizializzato nel costruttore come segue.
\begin{lstlisting}
private ArrayList <OrdinarynodeFiles> file_list;

public SupernodeOnFileList(){
	this.file_list = new ArrayList();
}
\end{lstlisting}
Questa classe mette a disposizione anche diversi metodi utili a manipolare le informazioni che si trovano all'interno dell'\emph{ArrayList}.
\subsection{addNewOnFileList}
Un metodo che serve all'inserimento di nuove liste di files. Questo metodo si accorge se è già presente una lista di file per un determinato nodo e, nel caso, sostituisce la lista vecchia con la lista nuova.
Ciò semplifica la gestione delle liste riducendo le operazioni di add, update e remove a una sola operazione, e di conseguenza gli errori in cui si può incorrere.
Nel caso non esista già una lista per il nodo mittente, si aggiunge un nuovo campo all'\emph{ArrayList} \verb|file_list|.
Mostriamo quindi il frammento di codice che si occupa di queste operazioni.
\begin{lstlisting}
for(OrdinarynodeFiles o : this.file_list){
	if(o.getOwner().getId().equals(new_file_list.getOwner().getId())){
		//Abbiamo già una lista per il nodo Owner
		o.resetList(new_file_list.getFileList());
		return;
	}
}

this.file_list.add(new_file_list);
\end{lstlisting}

\section{Smistamento delle query}\label{sec:smistamento_delle_query}
%SupernodeQueryList.java

\section{Il cuore di un Super Node}
\subsection{Engine}

\subsection{SN e RMI}

\subsection{SN in ascolto su socket TCP}
